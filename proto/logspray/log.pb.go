// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/logspray/log.proto

/*
Package logspray is a generated protocol buffer package.

It is generated from these files:
	proto/logspray/log.proto

It has these top-level messages:
	Message
	LogSummary
	TailRequest
	LabelsRequest
	LabelsResponse
	LabelValuesRequest
	LabelValuesResponse
	SearchRequest
	SearchResponse
*/
package logspray

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Message_ControlMessage int32

const (
	Message_NONE      Message_ControlMessage = 0
	Message_OK        Message_ControlMessage = 1
	Message_ERROR     Message_ControlMessage = 2
	Message_SETHEADER Message_ControlMessage = 3
	Message_STREAMEND Message_ControlMessage = 4
)

var Message_ControlMessage_name = map[int32]string{
	0: "NONE",
	1: "OK",
	2: "ERROR",
	3: "SETHEADER",
	4: "STREAMEND",
}
var Message_ControlMessage_value = map[string]int32{
	"NONE":      0,
	"OK":        1,
	"ERROR":     2,
	"SETHEADER": 3,
	"STREAMEND": 4,
}

func (x Message_ControlMessage) String() string {
	return proto.EnumName(Message_ControlMessage_name, int32(x))
}
func (Message_ControlMessage) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

// Message
type Message struct {
	Time           *google_protobuf1.Timestamp `protobuf:"bytes,1,opt,name=time" json:"time,omitempty"`
	Labels         map[string]string           `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Setheader      bool                        `protobuf:"varint,3,opt,name=setheader" json:"setheader,omitempty"`
	Text           string                      `protobuf:"bytes,4,opt,name=text" json:"text,omitempty"`
	ControlMessage Message_ControlMessage      `protobuf:"varint,5,opt,name=control_message,json=controlMessage,enum=logspray.Message_ControlMessage" json:"control_message,omitempty"`
	StreamID       string                      `protobuf:"bytes,6,opt,name=StreamID,json=streamID" json:"StreamID,omitempty"`
	Index          uint64                      `protobuf:"varint,7,opt,name=Index,json=index" json:"Index,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Message) GetTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *Message) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Message) GetSetheader() bool {
	if m != nil {
		return m.Setheader
	}
	return false
}

func (m *Message) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Message) GetControlMessage() Message_ControlMessage {
	if m != nil {
		return m.ControlMessage
	}
	return Message_NONE
}

func (m *Message) GetStreamID() string {
	if m != nil {
		return m.StreamID
	}
	return ""
}

func (m *Message) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

// LogSummary
type LogSummary struct {
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
}

func (m *LogSummary) Reset()                    { *m = LogSummary{} }
func (m *LogSummary) String() string            { return proto.CompactTextString(m) }
func (*LogSummary) ProtoMessage()               {}
func (*LogSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *LogSummary) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// TailRequest
type TailRequest struct {
	Max   int64  `protobuf:"varint,1,opt,name=max" json:"max,omitempty"`
	Query string `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"`
}

func (m *TailRequest) Reset()                    { *m = TailRequest{} }
func (m *TailRequest) String() string            { return proto.CompactTextString(m) }
func (*TailRequest) ProtoMessage()               {}
func (*TailRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TailRequest) GetMax() int64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *TailRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

// LabelsRequest
type LabelsRequest struct {
	From *google_protobuf1.Timestamp `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	To   *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=to" json:"to,omitempty"`
}

func (m *LabelsRequest) Reset()                    { *m = LabelsRequest{} }
func (m *LabelsRequest) String() string            { return proto.CompactTextString(m) }
func (*LabelsRequest) ProtoMessage()               {}
func (*LabelsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *LabelsRequest) GetFrom() *google_protobuf1.Timestamp {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *LabelsRequest) GetTo() *google_protobuf1.Timestamp {
	if m != nil {
		return m.To
	}
	return nil
}

// LabelsResponse
type LabelsResponse struct {
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *LabelsResponse) Reset()                    { *m = LabelsResponse{} }
func (m *LabelsResponse) String() string            { return proto.CompactTextString(m) }
func (*LabelsResponse) ProtoMessage()               {}
func (*LabelsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *LabelsResponse) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// LabelValuesRequest
type LabelValuesRequest struct {
	From  *google_protobuf1.Timestamp `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	To    *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=to" json:"to,omitempty"`
	Name  string                      `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Count int64                       `protobuf:"varint,4,opt,name=count" json:"count,omitempty"`
}

func (m *LabelValuesRequest) Reset()                    { *m = LabelValuesRequest{} }
func (m *LabelValuesRequest) String() string            { return proto.CompactTextString(m) }
func (*LabelValuesRequest) ProtoMessage()               {}
func (*LabelValuesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *LabelValuesRequest) GetFrom() *google_protobuf1.Timestamp {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *LabelValuesRequest) GetTo() *google_protobuf1.Timestamp {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *LabelValuesRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LabelValuesRequest) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// LabelValuesResponse
type LabelValuesResponse struct {
	Values        []string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
	TotalHitCount uint64   `protobuf:"varint,2,opt,name=total_hit_count,json=totalHitCount" json:"total_hit_count,omitempty"`
}

func (m *LabelValuesResponse) Reset()                    { *m = LabelValuesResponse{} }
func (m *LabelValuesResponse) String() string            { return proto.CompactTextString(m) }
func (*LabelValuesResponse) ProtoMessage()               {}
func (*LabelValuesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *LabelValuesResponse) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *LabelValuesResponse) GetTotalHitCount() uint64 {
	if m != nil {
		return m.TotalHitCount
	}
	return 0
}

// SearchRequest
type SearchRequest struct {
	From    *google_protobuf1.Timestamp `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	To      *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=to" json:"to,omitempty"`
	Query   string                      `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	Count   uint64                      `protobuf:"varint,4,opt,name=count" json:"count,omitempty"`
	Offset  uint64                      `protobuf:"varint,5,opt,name=offset" json:"offset,omitempty"`
	Reverse bool                        `protobuf:"varint,6,opt,name=reverse" json:"reverse,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SearchRequest) GetFrom() *google_protobuf1.Timestamp {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *SearchRequest) GetTo() *google_protobuf1.Timestamp {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *SearchRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SearchRequest) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SearchRequest) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SearchRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

// SearchResponse
type SearchResponse struct {
	Messages      []*Message `protobuf:"bytes,1,rep,name=messages" json:"messages,omitempty"`
	TotalHitCount uint64     `protobuf:"varint,2,opt,name=total_hit_count,json=totalHitCount" json:"total_hit_count,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SearchResponse) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *SearchResponse) GetTotalHitCount() uint64 {
	if m != nil {
		return m.TotalHitCount
	}
	return 0
}

func init() {
	proto.RegisterType((*Message)(nil), "logspray.Message")
	proto.RegisterType((*LogSummary)(nil), "logspray.LogSummary")
	proto.RegisterType((*TailRequest)(nil), "logspray.TailRequest")
	proto.RegisterType((*LabelsRequest)(nil), "logspray.LabelsRequest")
	proto.RegisterType((*LabelsResponse)(nil), "logspray.LabelsResponse")
	proto.RegisterType((*LabelValuesRequest)(nil), "logspray.LabelValuesRequest")
	proto.RegisterType((*LabelValuesResponse)(nil), "logspray.LabelValuesResponse")
	proto.RegisterType((*SearchRequest)(nil), "logspray.SearchRequest")
	proto.RegisterType((*SearchResponse)(nil), "logspray.SearchResponse")
	proto.RegisterEnum("logspray.Message_ControlMessage", Message_ControlMessage_name, Message_ControlMessage_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for LogService service

type LogServiceClient interface {
	// LogStream ingests the stream of messages
	// The first message sent in a stream should set
	// an initial set of default labels. You must provide a UUID
	// for the stream, and each message should include an incrementing
	// index into that stream.
	//   The client assign the UUID, and Index, rather than the server,
	// making it the singe source of truth for a given log item, and allowing
	// potential deduplication of log itmes later on.
	LogStream(ctx context.Context, opts ...grpc.CallOption) (LogService_LogStreamClient, error)
	// Log logs an individual message.
	Log(ctx context.Context, in *Message, opts ...grpc.CallOption) (*LogSummary, error)
	// Tail returns a stream of log data that matches the
	// query in the TailRequest. When reading the stream
	// clients should pay attention to ControlMessage_SETHEADER
	// events which include the base sets of labels for a stream.
	// These labels should be added to log entries associated with
	// that stream.
	Tail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (LogService_TailClient, error)
	// Search takes a string query
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// SearchStream takes a string query and returns results as a stream.
	SearchStream(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (LogService_SearchStreamClient, error)
	// Labels returns the set of labels known in the current index
	// active index.
	Labels(ctx context.Context, in *LabelsRequest, opts ...grpc.CallOption) (*LabelsResponse, error)
	// LabelsValue returns the set of values for a label  known in the current
	// index active index. (from/to are currently ignored)
	LabelValues(ctx context.Context, in *LabelValuesRequest, opts ...grpc.CallOption) (*LabelValuesResponse, error)
}

type logServiceClient struct {
	cc *grpc.ClientConn
}

func NewLogServiceClient(cc *grpc.ClientConn) LogServiceClient {
	return &logServiceClient{cc}
}

func (c *logServiceClient) LogStream(ctx context.Context, opts ...grpc.CallOption) (LogService_LogStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_LogService_serviceDesc.Streams[0], c.cc, "/logspray.LogService/LogStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &logServiceLogStreamClient{stream}
	return x, nil
}

type LogService_LogStreamClient interface {
	Send(*Message) error
	CloseAndRecv() (*LogSummary, error)
	grpc.ClientStream
}

type logServiceLogStreamClient struct {
	grpc.ClientStream
}

func (x *logServiceLogStreamClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *logServiceLogStreamClient) CloseAndRecv() (*LogSummary, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(LogSummary)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logServiceClient) Log(ctx context.Context, in *Message, opts ...grpc.CallOption) (*LogSummary, error) {
	out := new(LogSummary)
	err := grpc.Invoke(ctx, "/logspray.LogService/Log", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) Tail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (LogService_TailClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_LogService_serviceDesc.Streams[1], c.cc, "/logspray.LogService/Tail", opts...)
	if err != nil {
		return nil, err
	}
	x := &logServiceTailClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LogService_TailClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type logServiceTailClient struct {
	grpc.ClientStream
}

func (x *logServiceTailClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logServiceClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := grpc.Invoke(ctx, "/logspray.LogService/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) SearchStream(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (LogService_SearchStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_LogService_serviceDesc.Streams[2], c.cc, "/logspray.LogService/SearchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &logServiceSearchStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LogService_SearchStreamClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type logServiceSearchStreamClient struct {
	grpc.ClientStream
}

func (x *logServiceSearchStreamClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logServiceClient) Labels(ctx context.Context, in *LabelsRequest, opts ...grpc.CallOption) (*LabelsResponse, error) {
	out := new(LabelsResponse)
	err := grpc.Invoke(ctx, "/logspray.LogService/Labels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) LabelValues(ctx context.Context, in *LabelValuesRequest, opts ...grpc.CallOption) (*LabelValuesResponse, error) {
	out := new(LabelValuesResponse)
	err := grpc.Invoke(ctx, "/logspray.LogService/LabelValues", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for LogService service

type LogServiceServer interface {
	// LogStream ingests the stream of messages
	// The first message sent in a stream should set
	// an initial set of default labels. You must provide a UUID
	// for the stream, and each message should include an incrementing
	// index into that stream.
	//   The client assign the UUID, and Index, rather than the server,
	// making it the singe source of truth for a given log item, and allowing
	// potential deduplication of log itmes later on.
	LogStream(LogService_LogStreamServer) error
	// Log logs an individual message.
	Log(context.Context, *Message) (*LogSummary, error)
	// Tail returns a stream of log data that matches the
	// query in the TailRequest. When reading the stream
	// clients should pay attention to ControlMessage_SETHEADER
	// events which include the base sets of labels for a stream.
	// These labels should be added to log entries associated with
	// that stream.
	Tail(*TailRequest, LogService_TailServer) error
	// Search takes a string query
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	// SearchStream takes a string query and returns results as a stream.
	SearchStream(*SearchRequest, LogService_SearchStreamServer) error
	// Labels returns the set of labels known in the current index
	// active index.
	Labels(context.Context, *LabelsRequest) (*LabelsResponse, error)
	// LabelsValue returns the set of values for a label  known in the current
	// index active index. (from/to are currently ignored)
	LabelValues(context.Context, *LabelValuesRequest) (*LabelValuesResponse, error)
}

func RegisterLogServiceServer(s *grpc.Server, srv LogServiceServer) {
	s.RegisterService(&_LogService_serviceDesc, srv)
}

func _LogService_LogStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LogServiceServer).LogStream(&logServiceLogStreamServer{stream})
}

type LogService_LogStreamServer interface {
	SendAndClose(*LogSummary) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type logServiceLogStreamServer struct {
	grpc.ServerStream
}

func (x *logServiceLogStreamServer) SendAndClose(m *LogSummary) error {
	return x.ServerStream.SendMsg(m)
}

func (x *logServiceLogStreamServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _LogService_Log_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Log(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/logspray.LogService/Log",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Log(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_Tail_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TailRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogServiceServer).Tail(m, &logServiceTailServer{stream})
}

type LogService_TailServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type logServiceTailServer struct {
	grpc.ServerStream
}

func (x *logServiceTailServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _LogService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/logspray.LogService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_SearchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogServiceServer).SearchStream(m, &logServiceSearchStreamServer{stream})
}

type LogService_SearchStreamServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type logServiceSearchStreamServer struct {
	grpc.ServerStream
}

func (x *logServiceSearchStreamServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _LogService_Labels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LabelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Labels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/logspray.LogService/Labels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Labels(ctx, req.(*LabelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_LabelValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LabelValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).LabelValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/logspray.LogService/LabelValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).LabelValues(ctx, req.(*LabelValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LogService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "logspray.LogService",
	HandlerType: (*LogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Log",
			Handler:    _LogService_Log_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _LogService_Search_Handler,
		},
		{
			MethodName: "Labels",
			Handler:    _LogService_Labels_Handler,
		},
		{
			MethodName: "LabelValues",
			Handler:    _LogService_LabelValues_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LogStream",
			Handler:       _LogService_LogStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Tail",
			Handler:       _LogService_Tail_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchStream",
			Handler:       _LogService_SearchStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/logspray/log.proto",
}

func init() { proto.RegisterFile("proto/logspray/log.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 838 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x2e, 0x7f, 0x24, 0x4b, 0xa3, 0x58, 0x56, 0x26, 0x69, 0xc3, 0x10, 0x0e, 0x20, 0xf0, 0x60,
	0x08, 0x06, 0x42, 0xa6, 0x2a, 0xdc, 0x1f, 0x03, 0x3d, 0xa4, 0xb1, 0x80, 0x18, 0x76, 0x6c, 0x74,
	0xed, 0xf6, 0x6a, 0xd0, 0xf2, 0x5a, 0x26, 0x4c, 0x72, 0x15, 0xee, 0xca, 0xb0, 0x61, 0xf8, 0xd0,
	0xbe, 0x42, 0x6f, 0x7d, 0x81, 0x3e, 0x4b, 0xcf, 0x79, 0x85, 0x3e, 0x48, 0xb1, 0xb3, 0xa4, 0x25,
	0x55, 0x4d, 0xa0, 0x5c, 0x7c, 0xdb, 0x6f, 0x67, 0xf6, 0xfb, 0x66, 0x66, 0x67, 0x06, 0xbc, 0x71,
	0x21, 0x94, 0x88, 0x52, 0x31, 0x92, 0xe3, 0x22, 0xbe, 0xd1, 0x87, 0x90, 0xae, 0xb0, 0x51, 0xdd,
	0xf9, 0xeb, 0x23, 0x21, 0x46, 0x29, 0x8f, 0xe2, 0x71, 0x12, 0xc5, 0x79, 0x2e, 0x54, 0xac, 0x12,
	0x91, 0x4b, 0xe3, 0xe7, 0x3f, 0x57, 0x49, 0xc6, 0xa5, 0x8a, 0xb3, 0x71, 0x74, 0x7f, 0x32, 0xa6,
	0xe0, 0x2f, 0x07, 0x56, 0xde, 0x71, 0x29, 0xe3, 0x11, 0xc7, 0x10, 0x5c, 0x6d, 0xf6, 0xac, 0xae,
	0xd5, 0x6b, 0xf5, 0xfd, 0xd0, 0x70, 0x1a, 0xc7, 0xd3, 0xc9, 0x79, 0x78, 0x5c, 0xbd, 0x65, 0xe4,
	0x87, 0x5b, 0x50, 0x4f, 0xe3, 0x53, 0x9e, 0x4a, 0xcf, 0xee, 0x3a, 0xbd, 0x56, 0xff, 0x45, 0x58,
	0xc5, 0x13, 0x96, 0x94, 0xe1, 0x3e, 0xd9, 0x07, 0xb9, 0x2a, 0x6e, 0x58, 0xe9, 0x8c, 0xeb, 0xd0,
	0x94, 0x5c, 0x5d, 0xf0, 0xf8, 0x8c, 0x17, 0x9e, 0xd3, 0xb5, 0x7a, 0x0d, 0x36, 0xbd, 0x40, 0x04,
	0x57, 0xf1, 0x6b, 0xe5, 0xb9, 0x5d, 0xab, 0xd7, 0x64, 0x74, 0xc6, 0x5d, 0x58, 0x1b, 0x8a, 0x5c,
	0x15, 0x22, 0x3d, 0xc9, 0x0c, 0xb1, 0x57, 0xeb, 0x5a, 0xbd, 0x76, 0xbf, 0xbb, 0xa8, 0xf8, 0xc6,
	0x38, 0x96, 0x90, 0xb5, 0x87, 0x73, 0x18, 0x7d, 0x68, 0x1c, 0xa9, 0x82, 0xc7, 0xd9, 0xee, 0x8e,
	0x57, 0x27, 0x89, 0x86, 0x2c, 0x31, 0x3e, 0x85, 0xda, 0x6e, 0x7e, 0xc6, 0xaf, 0xbd, 0x95, 0xae,
	0xd5, 0x73, 0x59, 0x2d, 0xd1, 0xc0, 0xff, 0x01, 0x5a, 0x33, 0x59, 0x60, 0x07, 0x9c, 0x4b, 0x7e,
	0x43, 0x35, 0x6a, 0x32, 0x7d, 0xd4, 0xcf, 0xae, 0xe2, 0x74, 0xc2, 0x3d, 0x9b, 0xee, 0x0c, 0xd8,
	0xb6, 0xbf, 0xb7, 0x82, 0x3d, 0x68, 0xcf, 0x87, 0x83, 0x0d, 0x70, 0x0f, 0x0e, 0x0f, 0x06, 0x9d,
	0x2f, 0xb0, 0x0e, 0xf6, 0xe1, 0x5e, 0xc7, 0xc2, 0x26, 0xd4, 0x06, 0x8c, 0x1d, 0xb2, 0x8e, 0x8d,
	0xab, 0xd0, 0x3c, 0x1a, 0x1c, 0xbf, 0x1d, 0xbc, 0xde, 0x19, 0xb0, 0x8e, 0x43, 0xf0, 0x98, 0x0d,
	0x5e, 0xbf, 0x1b, 0x1c, 0xec, 0x74, 0xdc, 0x20, 0x00, 0xd8, 0x17, 0xa3, 0xa3, 0x49, 0x96, 0xc5,
	0x05, 0x89, 0x0e, 0xc5, 0x24, 0x57, 0x14, 0x88, 0xc3, 0x0c, 0x08, 0xb6, 0xa0, 0x75, 0x1c, 0x27,
	0x29, 0xe3, 0xef, 0x27, 0x5c, 0x2a, 0x1d, 0x6b, 0x16, 0x5f, 0x97, 0x2e, 0xfa, 0xa8, 0x9f, 0xbd,
	0x9f, 0xf0, 0xe2, 0xa6, 0x8a, 0x95, 0x40, 0x70, 0x09, 0xab, 0x26, 0xc5, 0xea, 0x61, 0x08, 0xee,
	0x79, 0x21, 0xb2, 0x65, 0x3a, 0x41, 0xfb, 0xe1, 0x26, 0xd8, 0x4a, 0x10, 0xe7, 0xa7, 0xbd, 0x6d,
	0x25, 0x82, 0x0d, 0x68, 0x57, 0x62, 0x72, 0x2c, 0x72, 0xc9, 0x75, 0x50, 0x79, 0x9c, 0x71, 0xe9,
	0x59, 0x5d, 0x47, 0x07, 0x45, 0x20, 0xf8, 0xd3, 0x02, 0x24, 0xc7, 0x5f, 0x75, 0x3d, 0x1f, 0x22,
	0x34, 0xdd, 0x7b, 0x5a, 0x9b, 0x9a, 0xb2, 0xc9, 0xe8, 0x3c, 0x2d, 0xb4, 0x3b, 0x5b, 0xe8, 0x5f,
	0xe0, 0xc9, 0x5c, 0x6c, 0x65, 0x26, 0x5f, 0x41, 0x9d, 0x7e, 0xbf, 0x4a, 0xa5, 0x44, 0xb8, 0x01,
	0x6b, 0x4a, 0xa8, 0x38, 0x3d, 0xb9, 0x48, 0xd4, 0x89, 0xa1, 0xb3, 0xa9, 0xc7, 0x56, 0xe9, 0xfa,
	0x6d, 0xa2, 0xde, 0x10, 0xed, 0xdf, 0x16, 0xac, 0x1e, 0xf1, 0xb8, 0x18, 0x5e, 0x3c, 0x44, 0xba,
	0xf7, 0xcd, 0xe0, 0xcc, 0x34, 0xc3, 0x7c, 0xc2, 0x6e, 0x99, 0xb0, 0xce, 0x4c, 0x9c, 0x9f, 0x4b,
	0xae, 0x68, 0xf2, 0x5c, 0x56, 0x22, 0xf4, 0x60, 0xa5, 0xe0, 0x57, 0xbc, 0x90, 0x9c, 0xc6, 0xa9,
	0xc1, 0x2a, 0x18, 0x8c, 0xa0, 0x5d, 0xa5, 0x52, 0x56, 0xe7, 0x25, 0x34, 0xca, 0xf1, 0x35, 0xf5,
	0x69, 0xf5, 0x1f, 0x2f, 0xcc, 0x2f, 0xbb, 0x77, 0x59, 0xb6, 0x68, 0xfd, 0x0f, 0x35, 0x33, 0x19,
	0xbc, 0xb8, 0x4a, 0x86, 0x1c, 0x7f, 0x86, 0xa6, 0x46, 0x34, 0xd4, 0xb8, 0x28, 0xe0, 0x3f, 0x9d,
	0x5e, 0x4d, 0xe7, 0x29, 0x78, 0xfe, 0xfb, 0x87, 0x7f, 0xfe, 0xb0, 0x9f, 0x04, 0xed, 0xe8, 0xea,
	0x6b, 0xbd, 0x61, 0x23, 0xb3, 0x15, 0xb6, 0xad, 0xcd, 0x9e, 0x85, 0x3f, 0x81, 0xb3, 0x2f, 0x46,
	0xcb, 0x93, 0x21, 0x91, 0x3d, 0x0a, 0x56, 0x4a, 0xb2, 0x6d, 0x6b, 0x13, 0xf7, 0xc0, 0xd5, 0xa3,
	0x89, 0x5f, 0x4e, 0x5f, 0xcc, 0x8c, 0xaa, 0xbf, 0xc8, 0x1d, 0x3c, 0x23, 0x96, 0xc7, 0xb8, 0xa6,
	0x59, 0x54, 0x9c, 0xa4, 0x65, 0x4c, 0xaf, 0x2c, 0x94, 0x50, 0x37, 0xb5, 0xc5, 0x67, 0xd3, 0x77,
	0x73, 0x8d, 0xe3, 0x7b, 0x8b, 0x06, 0xf3, 0x0d, 0xc1, 0xb7, 0xc4, 0xfb, 0x0a, 0x43, 0xcd, 0x2b,
	0xc9, 0x16, 0xdd, 0xea, 0xe6, 0x09, 0x25, 0x1f, 0x8a, 0xfc, 0x4c, 0xde, 0x45, 0xb7, 0x4a, 0xcc,
	0x00, 0xea, 0x8b, 0x3b, 0xbc, 0x85, 0x47, 0x86, 0xa9, 0xac, 0xed, 0x47, 0xa5, 0xff, 0x27, 0x97,
	0x1f, 0x49, 0xf3, 0x3b, 0xdc, 0xfa, 0x3c, 0xcd, 0x69, 0xc6, 0x97, 0x50, 0x37, 0x5b, 0x63, 0x56,
	0x76, 0x6e, 0x69, 0xcd, 0x66, 0x3c, 0xbf, 0x60, 0x82, 0x90, 0xd4, 0x7b, 0xb8, 0x41, 0xff, 0x41,
	0xb6, 0x4f, 0xa9, 0xe3, 0x6f, 0x56, 0xb9, 0xf3, 0xcd, 0x78, 0xe3, 0xfa, 0x7f, 0x98, 0xe7, 0x36,
	0x92, 0xff, 0xe2, 0x23, 0xd6, 0x52, 0x7c, 0x8b, 0xc4, 0x23, 0x7c, 0xb9, 0x9c, 0x78, 0x74, 0xab,
	0xd7, 0xce, 0xdd, 0x69, 0x9d, 0x86, 0xf6, 0x9b, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xe4, 0x70,
	0xa8, 0xc8, 0xfe, 0x07, 0x00, 0x00,
}
